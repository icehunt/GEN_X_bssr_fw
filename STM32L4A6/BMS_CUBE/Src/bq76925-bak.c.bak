/*
 * bq76925.cpp
 *
 *  Created on: 2019
 *      Author: wuyuc
 */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "bq76925.h"
#include "FreeRTOS.h"
#include "semphr.h"

static SemaphoreHandle_t xADCSemaphore = NULL;
static BaseType_t xTaskWokenByReceive = pdFALSE;

const uint8_t BqCellSel[7] = {
	BQ_VCSEL_VSS,
	BQ_VCSEL_VC1,
	BQ_VCSEL_VC2,
	BQ_VCSEL_VC3,
	BQ_VCSEL_VC4,
	BQ_VCSEL_VC5,
	BQ_VCSEL_VC6,
};

static void log(UART_HandleTypeDef* uart, char * msg) {
    HAL_UART_Transmit(uart, msg, strlen(msg), 100);
}

uint8_t BQ_getADCRunning(BQ_t * bq) {
    uint8_t value = 0;
    if( xSemaphoreTakeFromISR( xADCSemaphore, &xTaskWokenByReceive)){
        /* We were able to obtain the semaphore and can now access the
        shared resource. */

        value = bq->adcRunning;

        /* We have finished accessing the shared resource.  Release the
        semaphore. */
        xSemaphoreGiveFromISR( xADCSemaphore , &xTaskWokenByReceive);            
    }
}

void BQ_setADCRunning(BQ_t * bq, uint8_t value) {
    if( xSemaphoreTakeFromISR( xADCSemaphore, &xTaskWokenByReceive)){
        /* We were able to obtain the semaphore and can now access the
        shared resource. */

        bq->adcRunning = value;

        /* We have finished accessing the shared resource.  Release the
        semaphore. */
        xSemaphoreGiveFromISR( xADCSemaphore , &xTaskWokenByReceive);
    }
}

void BQ_Error(BQ_t *bq)
{
    for (;;)
    {
        // stop here
    }
}

uint8_t BQ_i2cTest(BQ_t* bq) {
    uint8_t data;
    // check for device id, this should be 0x10
    if (HAL_OK == HAL_I2C_Master_Receive(bq->i2c, 0x4e, &data, 1, 100)) {
        if (data == 0x10) return BQ_OK;
    }
    return BQ_ERROR;
}

void BQ_logAllReg(BQ_t* bq, UART_HandleTypeDef* uart) {
    log(uart, "BQ REG = \r\n");
    char buffer[100];
    for (int i = 0; i < 0x20; i++) {
        sprintf(buffer, "\treg[ 0x%02X ] = 0x%02X\r\n", i, bq->regMap[i]);
        log(uart, buffer);
    }
}

void BQ_writeI2C_IT(BQ_t *bq, uint8_t address, BqI2CTask task)
{
    bq->interrupt.mode = BQ_WRITE;
    bq->interrupt.address = address;
    bq->interrupt.task = task;
#ifdef DEBUG
    if (address >= 0x20)
    {
        BQ_Error(bq);
    }
    else if (bq->i2c == NULL)
    {
        BQ_Error(bq);
    }
#endif
	if (HAL_OK != HAL_I2C_Master_Transmit_IT(bq->i2c, 
            ((BQ_GROUP_ADDRESS << 3) | (address & 0x1F)) << 1, bq->regMap + (address & 0x1F), 1))
        BQ_Error(bq);
}

void BQ_readI2C_IT(BQ_t *bq, uint8_t address, BqI2CTask task)
{
    bq->interrupt.mode = BQ_READ;
    bq->interrupt.address = address;
    bq->interrupt.task = task;
#ifdef DEBUG
    if (address >= 0x20)
    {
        BQ_Error(bq);
    }
    else if (bq->i2c == NULL)
    {
        BQ_Error(bq);
    }
#endif
    if (HAL_OK != HAL_I2C_Master_Receive_IT(bq->i2c,
            ((BQ_GROUP_ADDRESS << 3) | (address & 0x1F)) << 1, bq->regMap + (address & 0x1F), 1))
    BQ_Error(bq);
}

uint8_t BQ_getCurrentAlert(BQ_t *bq)
{
    return bq->regMap[STATUS_ADDRESS] & BQ_CURRENT_ALERT;
}

uint8_t BQ_getCrcErr(BQ_t *bq)
{
    return bq->regMap[STATUS_ADDRESS] & BQ_CRC_ERR;
}

uint8_t BQ_getRefSel(BQ_t *bq)
{
    return bq->regMap[CONFIG_2_ADDRESS] & BQ_REF_SEL;
}

uint8_t BQ_getChipId(BQ_t *bq)
{
    return bq->regMap[CHIP_ID_ADDRESS];
}

void BQ_setRefSel(BQ_t *bq, uint8_t sel)
{
#ifdef DEBUG
    if (sel > 1)
        BQ_Error(bq);
#endif
    bq->regMap[CONFIG_2_ADDRESS] = (bq->regMap[CONFIG_2_ADDRESS] & (~BQ_REF_SEL)) | sel;
    bq->regMap[POWER_CTL_ADDRESS] |= BQ_REF_EN;
}
void BQ_setSleep(BQ_t *bq, uint8_t s)
{
#ifdef DEBUG
    if (s > 1)
        BQ_Error(bq);
#endif
    bq->regMap[POWER_CTL_ADDRESS] = (bq->regMap[POWER_CTL_ADDRESS] & (~BQ_SLEEP)) | (s << 7);
    bq->regMap[POWER_CTL_ADDRESS] = (bq->regMap[POWER_CTL_ADDRESS] & (~BQ_SLEEP_DIS)) | ((1 - s) << 6);
}

void BQ_readBattery(BQ_t *bq, uint8_t index)
{
    static int readProgress = 0;
    if (index == 0)
        index = bq->batIndex;
#ifdef DEBUG
    if (index > 6 || index == 0)
        BQ_Error(bq);
    if (bq->batSetCallback == NULL || bq->batDoneCallback == NULL)
        BQ_Error(bq);
#endif
    if (!index) return;
    if (bq->interrupt.task == IDLE)
    {
        BQ_setADCRunning(bq, 0);
        // start of the task
        // step 1 cell sel
        bq->batIndex = index;
        bq->regMap[CELL_CTL_ADDRESS] = BqCellSel[index];
        BQ_writeI2C_IT(bq, CELL_CTL_ADDRESS, READ_BAT);
    }
    else if (bq->interrupt.mode == BQ_WRITE && bq->interrupt.address == CELL_CTL_ADDRESS)
    {
        // step 2 let adc start reading
        BQ_setADCRunning(bq, 1);
        if (bq->batSetCallback != NULL)
            bq->batSetCallback(bq);
        // start read all register
        readProgress = 0;
        BQ_readI2C_IT(bq, readProgress, READ_BAT);
    }
    else if (bq->interrupt.mode == BQ_READ && bq->interrupt.address == readProgress &&
                readProgress < 0x1F) {
        readProgress ++;
        BQ_readI2C_IT(bq, readProgress, READ_BAT);
    }
    else if (bq->interrupt.mode == BQ_READ && bq->interrupt.address == VREF_CAL_ADDRESS + index)
    {
        // bq->batIndex = 0;
        // reading part done
        bq->interrupt.task = IDLE;
        if (bq->batDoneCallback != NULL)
            bq->batDoneCallback(bq);
    }
}

double BQ_getVoltage(BQ_t *bq, double ADC_read) {
    double VREF_NOMINAL = BQ_getRefSel(bq) ? 3 : 1.5;
    double G_VCOUT = BQ_getRefSel(bq) ? 0.6 : 0.3;

    uint8_t VCn_GC_4, VCn_GAIN_CORR, VCn_OC_4, VCn_OFFSET_CORR;
    switch (bq->batIndex)
    {
    case 1:
        VCn_OFFSET_CORR = (bq->regMap[VC1_CAL_ADDRESS] >> 4) & 0xF;
        VCn_GAIN_CORR = bq->regMap[VC1_CAL_ADDRESS] & 0xF;
        VCn_OC_4 = (bq->regMap[VC_CAL_EXT_1_ADDRESS] >> 7) & 0x1;
        VCn_GC_4 = (bq->regMap[VC_CAL_EXT_1_ADDRESS] >> 6) & 0x1;
        break;
    case 2:
        VCn_OFFSET_CORR = (bq->regMap[VC2_CAL_ADDRESS] >> 4) & 0xF;
        VCn_GAIN_CORR = bq->regMap[VC2_CAL_ADDRESS] & 0xF;
        VCn_OC_4 = (bq->regMap[VC_CAL_EXT_1_ADDRESS] >> 5) & 0x1;
        VCn_GC_4 = (bq->regMap[VC_CAL_EXT_1_ADDRESS] >> 4) & 0x1;
        break;
    case 3:
        VCn_OFFSET_CORR = (bq->regMap[VC3_CAL_ADDRESS] >> 4) & 0xF;
        VCn_GAIN_CORR = bq->regMap[VC3_CAL_ADDRESS] & 0xF;
        VCn_OC_4 = (bq->regMap[VC_CAL_EXT_2_ADDRESS] >> 7) & 0x1;
        VCn_GC_4 = (bq->regMap[VC_CAL_EXT_2_ADDRESS] >> 6) & 0x1;
        break;
    case 4:
        VCn_OFFSET_CORR = (bq->regMap[VC4_CAL_ADDRESS] >> 4) & 0xF;
        VCn_GAIN_CORR = bq->regMap[VC4_CAL_ADDRESS] & 0xF;
        VCn_OC_4 = (bq->regMap[VC_CAL_EXT_2_ADDRESS] >> 5) & 0x1;
        VCn_GC_4 = (bq->regMap[VC_CAL_EXT_2_ADDRESS] >> 4) & 0x1;
        break;
    case 5:
        VCn_OFFSET_CORR = (bq->regMap[VC5_CAL_ADDRESS] >> 4) & 0xF;
        VCn_GAIN_CORR = bq->regMap[VC5_CAL_ADDRESS] & 0xF;
        VCn_OC_4 = (bq->regMap[VC_CAL_EXT_2_ADDRESS] >> 3) & 0x1;
        VCn_GC_4 = (bq->regMap[VC_CAL_EXT_2_ADDRESS] >> 2) & 0x1;
        break;
    case 6:
        VCn_OFFSET_CORR = (bq->regMap[VC6_CAL_ADDRESS] >> 4) & 0xF;
        VCn_GAIN_CORR = bq->regMap[VC6_CAL_ADDRESS] & 0xF;
        VCn_OC_4 = (bq->regMap[VC_CAL_EXT_2_ADDRESS] >> 1) & 0x1;
        VCn_GC_4 = (bq->regMap[VC_CAL_EXT_2_ADDRESS] >> 0) & 0x1;
        break;
    default:
        BQ_Error(bq);
    }

    uint8_t VREF_GC_4 = bq->regMap[VREF_CAL_EXT_ADDRESS] & 0x1;
    uint8_t VREF_GAIN_CORR = bq->regMap[VREF_CAL_ADDRESS] & 0xF;
    uint8_t VREF_OC_5 = (bq->regMap[VREF_CAL_EXT_ADDRESS] >> 2) & 0x1;
    uint8_t VREF_OC_4 = (bq->regMap[VREF_CAL_EXT_ADDRESS] >> 1) & 0x1;
    uint8_t VREF_OFFSET_CORR = (bq->regMap[VREF_CAL_ADDRESS] >> 4) & 0xF;

    // ADC_Read = ADC_Count / Full_Scale_Count
    //  VREF_NOMINAL sels 1.5V or 3V by REF_SEL: CONFIG_2 = 0x04
    double VCOUT = ADC_read * VREF_NOMINAL;
    // VCn_GC_4 = 0x17 ~ 0x18
    // VCn_GAIN_CORR = 0x11 ~ 0x16
    double GC_VCOUT = ((VCn_GC_4 << 4) + VCn_GAIN_CORR) * 0.001;
    // VCn_OC_4  = px17 ~ 0x18
    // VCn_OFFSET_CORR = 0x11 ~ 0x16
    double OC_VCOUT = ((VCn_OC_4 << 4) + VCn_OFFSET_CORR) * 0.001;
    // VREF_GC_4  = 0x1B
    // VREF_GAIN_CORR = 0x10
    // VREF_OC_5  = 0x1B
    // VREF_OC_4  = 0x1B
    // VREF_OFFSET_CORR = 0x10
    // VREF_NOMINAL = 0x04
    double GC_VREF = (1 + ((VREF_GC_4 << 4) + VREF_GAIN_CORR) * 0.001) + 
                     ((VREF_OC_5 << 5) + (VREF_OC_4 << 4) + VREF_OFFSET_CORR) * 0.001 / 
                     VREF_NOMINAL;
    // char buffer[400];
    // sprintf(buffer, "")
    return (VCOUT * GC_VREF + OC_VCOUT) / G_VCOUT * (1 + GC_VCOUT);
}

void BQ_updateStatus_IT(BQ_t *bq)
{
    if (xADCSemaphore == NULL) xADCSemaphore = xSemaphoreCreateMutex();
    static int readProgress = 0;
    if (bq->interrupt.task == IDLE)
    {
        // start of the task
        // step 1 reset POR
        bq->regMap[STATUS_ADDRESS] = bq->regMap[STATUS_ADDRESS] & (!BQ_POWER);
        BQ_writeI2C_IT(bq, STATUS_ADDRESS, UPDATE_SATUS);
    }
    else if (bq->interrupt.mode == BQ_WRITE && bq->interrupt.address == STATUS_ADDRESS)
    {
        // step 2 set REF_EN
        BQ_writeI2C_IT(bq, POWER_CTL_ADDRESS, UPDATE_SATUS);
    }
    else if (bq->interrupt.mode == BQ_WRITE && bq->interrupt.address == POWER_CTL_ADDRESS)
    {
        // step 2 set CONFIG_2
        BQ_writeI2C_IT(bq, CONFIG_2_ADDRESS, UPDATE_SATUS);
    }
    else if (bq->interrupt.mode == BQ_WRITE && bq->interrupt.address == CONFIG_2_ADDRESS)
    {
        // step 3 read All reg
        readProgress = 0;
        BQ_readI2C_IT(bq, readProgress, UPDATE_SATUS);
    }
    else if (bq->interrupt.mode == BQ_READ && bq->interrupt.address == readProgress &&
                readProgress < 0x1F)
    {
        // step 4 read CHIP_ID
        readProgress ++;
        BQ_readI2C_IT(bq, readProgress, UPDATE_SATUS);
    }
    else
    {
        // end task
        bq->interrupt.task = IDLE;
        if (bq->statusUpdateDone != NULL) 
            bq->statusUpdateDone(bq);
    }
}

void BQ_I2cCallback(BQ_t *bq, I2C_HandleTypeDef *i2c)
{
    if (i2c != bq->i2c)
        return;
    if (bq->interrupt.mode == BQ_WRITE && bq->interrupt.task == USER_DEFINED && 
            bq->i2cTxCallback != NULL)
        bq->i2cTxCallback(bq);
    else if (bq->interrupt.mode == BQ_READ && bq->interrupt.task == USER_DEFINED && 
            bq->i2cRxCallback != NULL)
        bq->i2cRxCallback(bq);
    else if (bq->interrupt.task == UPDATE_SATUS)
        BQ_updateStatus_IT(bq);
    else if (bq->interrupt.task == READ_BAT)
        BQ_readBattery(bq, 0);
}
